<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>WebRTC DataChannel - Two Peer Demo</title>

    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
  </head>
  <body>
    <p id="servercode">...</p>
    <p id="turn">Turn:</p>

    <canvas
      id="canvas"
      width="800"
      height="800"
      style="border: 10px solid #000000"
    ></canvas>

    <script src="https://unpkg.com/peerjs@1.5.5/dist/peerjs.min.js"></script>
    <script src="src/Player.js"></script>
    <script src="src/Server.js"></script>
    <script src="src/Client.js"></script>
    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const turnText = document.getElementById("turn");

      const urlParams = new URLSearchParams(window.location.search);
      let code = urlParams.get("code");

      let server;
      let client;

      if (code == null) {
        server = new Server().then((code) => {
          console.log("Server up on client with code: " + code);
          document.getElementById("servercode").innerText = code;
          setup(code);
        });
      } else {
        setup(code);
      }

      let dragStartPos = { x: 0, y: 0 };
      let move = { x: 0, y: 0 };
      let aiming = false;

      window.requestAnimationFrame(gameLoop);
      function gameLoop() {
        if (server != null) {
          server.gameLoop();
        }
        window.requestAnimationFrame(gameLoop);
      }

      function setup(code) {
        client = new Client(code).onDataReceived((data) => {
          turnText.innerText = "Turn: " + data.turn;
          render(data);
        });
      }

      const colors = ["white", "white", "white", "white", "white"];

      function render(gameState) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        renderBackground();

        var i = 0;
        gameState.players.forEach((player) => {
          if (player.id == client.clientID) {
            if (aiming) {
              ctx.beginPath();
              ctx.moveTo(player.x, player.y);
              ctx.lineTo(player.x + move.x * 20, player.y + move.y * 20);
              ctx.stroke();
            }
          }

          drawBall(player, colors[i]);

          i++;
        });
      }

      function renderBackground() {
        const rows = 12;
        const cols = 12;
        const squareSize = canvas.width / cols;

        for (let row = 0; row < rows; row++) {
          for (let col = 0; col < cols; col++) {
            if ((row + col) % 2 === 0) {
              ctx.fillStyle = "green";
            } else {
              ctx.fillStyle = "lightgreen";
            }

            ctx.fillRect(
              col * squareSize,
              row * squareSize,
              squareSize,
              squareSize,
            );
          }
        }
      }

      function drawBall(player, color) {
        var RADIUS = 15;

        ctx.beginPath();
        ctx.arc(player.x, player.y, RADIUS, 0, 2 * Math.PI);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.lineWidth = 5;
        ctx.stroke();
      }

      canvas.addEventListener("mousedown", function (event) {
        dragStartPos = getMousePos(event);
        aiming = true;
      });

      canvas.addEventListener("mousemove", function (event) {
        if (!aiming) return;
        var mousePos = getMousePos(event);
        move.x = (dragStartPos.x - mousePos.x) / 50;
        move.y = (dragStartPos.y - mousePos.y) / 50;
      });

      canvas.addEventListener("mouseup", function (event) {
        client.sendMovement(move.x, move.y);
        aiming = false;
      });

      function getMousePos(evt) {
        var rect = canvas.getBoundingClientRect();
        return {
          x:
            ((evt.clientX - rect.left) / (rect.right - rect.left)) *
            canvas.width,
          y:
            ((evt.clientY - rect.top) / (rect.bottom - rect.top)) *
            canvas.height,
        };
      }
    </script>
  </body>
</html>

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>WebRTC DataChannel - Two Peer Demo</title>

    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
  </head>
  <body>
    <p id="servercode">...</p>
    <p id="turn">Turn:</p>

    <canvas
      id="canvas"
      width="800"
      height="800"
      style="border: 1px solid #000000"
    ></canvas>

    <script src="https://unpkg.com/peerjs@1.5.5/dist/peerjs.min.js"></script>
    <script src="src/Player.js"></script>
    <script src="src/Server.js"></script>
    <script src="src/Client.js"></script>
    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const turnText = document.getElementById("turn");

      const urlParams = new URLSearchParams(window.location.search);
      let code = urlParams.get("code");

      let server;
      let client;

      if (code == null) {
        server = new Server().then((code) => {
          console.log("Server up on client with code: " + code);
          document.getElementById("servercode").innerText = code;
          setup(code);
        });
      } else {
        setup(code);
      }

      window.requestAnimationFrame(gameLoop);
      function gameLoop() {
        if (server != null) {
          server.gameLoop();
        }
        window.requestAnimationFrame(gameLoop);
      }

      function setup(code) {
        client = new Client(code).onDataReceived((data) => {
          turnText.innerText = "Turn: " + data.turn;
          render(data);
        });
      }

      const colors = [
        "red",
        "green",
        "blue",
        "yellow",
        "cyan",
        "magenta",
        "black",
        "white",
        "gray",
        "silver",
        "maroon",
        "olive",
        "lime",
        "aqua",
        "teal",
        "navy",
        "fuchsia",
        "purple",
        "orange",
        "pink",
        "brown",
        "gold",
        "indigo",
        "violet",
        "turquoise",
        "beige",
        "coral",
        "crimson",
        "khaki",
        "lavender",
        "plum",
        "lemonchiffon",
        "lightblue",
        "lightcoral",
        "lightcyan",
        "lightsteelblue",
        "lightyellow",
        "moccasin",
        "navajowhite",
        "oldlace",
        "olivedrab",
        "orangered",
      ];

      function render(gameState) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        var i = 0;
        gameState.players.forEach((player) => {
          drawBall(player, colors[i]);
          i++;
        });
      }

      function drawBall(player, color) {
        var RADIUS = 15;

        ctx.fillStyle = color;
        ctx.fillRect(
          player.x - RADIUS,
          player.y - RADIUS,
          RADIUS * 2,
          RADIUS * 2,
        );
      }

      let dragStartPos = { x: 0, y: 0 };
      let move = { x: 0, y: 0 };
      let aiming = false;

      canvas.addEventListener("mousedown", function (event) {
        dragStartPos = getMousePos(event);
        aiming = true;
      });

      canvas.addEventListener("mousemove", function (event) {
        if (!aiming) return;
        var mousePos = getMousePos(event);
        move.x = (dragStartPos.x - mousePos.x) / 50;
        move.y = (dragStartPos.y - mousePos.y) / 50;
      });

      canvas.addEventListener("mouseup", function (event) {
        client.sendMovement(move.x, move.y);
        aiming = false;
      });

      function getMousePos(evt) {
        var rect = canvas.getBoundingClientRect();
        return {
          x:
            ((evt.clientX - rect.left) / (rect.right - rect.left)) *
            canvas.width,
          y:
            ((evt.clientY - rect.top) / (rect.bottom - rect.top)) *
            canvas.height,
        };
      }
    </script>
  </body>
</html>
